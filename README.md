# Drone Swarm Simulation

This project simulates a swarm of drones navigating a 2D environment. The drones aim to establish and maintain a communication corridor between a start and an end point. The simulation incorporates concepts like Boids for flocking behavior, energy management for drones, and network connectivity analysis.

## Project Structure

```
.
├── .gitignore
├── README.md
├── project_approach.md
├── project_knowledge/
├── prompts_examples.txt
├── prompts_for_project_approach.md
├── requirements.txt
├── run_simulation.py
└── src/
    ├── __init__.py (likely, though not explicitly listed by list_dir)
    ├── drone.py
    ├── environment.py
    └── main.py
```

- **`run_simulation.py`**: The main script to execute the simulation with specific parameters. This script initializes the `Environment` and runs the simulation loop, periodically printing metrics.
- **`src/drone.py`**: Defines the `Drone` class, which includes properties like position, energy, communication range, and methods for movement and state updates.
- **`src/environment.py`**: Defines the `Environment` class, which manages the simulation space, drone initialization, drone interactions (based on Boids rules and custom logic for corridor formation), connectivity graph (using `networkx`), and visualization (using `matplotlib`). It calculates various metrics related to swarm performance and corridor establishment.
- **`src/main.py`**: Contains an alternative main simulation logic (`run_simulation` function) with its own set of parameters. It also includes post-simulation analysis and plotting of metrics using `pandas` and `matplotlib`.
- **`requirements.txt`**: Lists the Python dependencies for the project (e.g., `numpy`, `networkx`, `matplotlib`, `pandas`).

## Features

- **Drone Swarm Behavior**: Drones exhibit flocking behavior based on Boids rules (separation, alignment, cohesion).
- **Corridor Navigation**: Drones attempt to form and maintain a path within a defined corridor between a start and end point.
- **Energy Management**: Drones consume energy for movement and idle time. They become inactive if they run out of energy.
- **Dynamic Connectivity**: The communication links between drones are dynamically updated based on their proximity and communication range. The simulation uses `networkx` to model and analyze this connectivity.
- **Anchor Points**: Special start and end nodes act as anchors, influencing drone behavior.
- **Metrics Collection**: The simulation tracks various metrics, including:
    - Number of active drones
    - Swarm connectivity (is the swarm connected, largest connected component)
    - Path existence between start and end nodes
    - Number of drones connected to the end node
    - Average drone energy
    - Drone distribution relative to the corridor
- **Visualization**: The simulation state, including drone positions, connectivity, and the corridor, is visualized in real-time using `matplotlib`.
- **Parameterization**: Key simulation parameters (e.g., number of drones, communication range, energy costs, Boids weights, corridor dimensions) are configurable.

## How to Run

1.  **Set up the environment:**
    Ensure you have Python installed. It's recommended to use a virtual environment.
    ```bash
    python -m venv .venv
    source .venv/bin/activate  # On Windows use `.\.venv\Scripts\activate`
    ```
2.  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
3.  **Run the simulation:**
    You can run the simulation using either `run_simulation.py` or by executing the `main.py` script directly.
    - Using `run_simulation.py`:
      ```bash
      python run_simulation.py
      ```
    - Using `src/main.py` (which might have different default parameters):
      ```bash
      python src/main.py
      ```

    The simulation will start, and a `matplotlib` window will open to visualize the drone swarm. Metrics will be printed to the console. After the simulation finishes (or is interrupted), final metrics and plots (if generated by `src/main.py`) will be displayed.

## Key Classes and Logic

### `Drone` Class (`src/drone.py`)

-   **Attributes**: `id`, `position`, `energy`, `comm_range`, `move_energy_cost`, `idle_energy_cost`, `neighbors`, `state` (active, inactive).
-   **Methods**:
    -   `move()`: Updates position based on velocity, consumes movement energy, and handles boundary collision.
    -   `update_state()`: Consumes idle energy and updates the drone's state (e.g., to inactive if energy is depleted).

### `Environment` Class (`src/environment.py`)

-   **Attributes**: `size`, `num_drones`, `drones` (dictionary of `Drone` objects), `comm_range`, energy parameters, corridor parameters (`start_point`, `end_point`, `corridor_width`), Boids weights, `connectivity_graph` (`networkx.Graph`), `time`, visualization elements (`fig`, `ax`).
-   **Methods**:
    -   `_initialize_drones()`: Places drones near the start point.
    -   `_update_connectivity()`: Updates the `connectivity_graph` based on drone proximity and communication range. Connects drones to start/end anchor nodes if they are in range.
    -   `step()`: Advances the simulation by one time step. This involves:
        1.  Getting actions (velocities) for drones via `_get_actions()`.
        2.  Moving drones.
        3.  Updating drone states (energy).
        4.  Updating connectivity.
        5.  Calculating metrics.
        6.  Checking termination conditions.
    -   `_get_actions()`: This is the core AI/control logic. It calculates the desired velocity for each active drone based on a combination of steering behaviors:
        -   **Separation**: Avoid crowding local flockmates.
        -   **Alignment**: Steer towards the average heading of local flockmates.
        -   **Cohesion**: Steer to move toward the average position of local flockmates.
        -   **Corridor Following**: Steer to stay within the defined corridor.
        -   **Base Anchoring**: Steer towards the start or end anchor points when nearby.
        -   **Connectivity Rescue**: If a drone has too few neighbors, steer towards its nearest neighbor.
        -   **Goal Steering**: A general pull towards the end point along the corridor axis.
        -   Drones hold their position if `corridor_established` flag is true (enough drones near the end point).
    -   `_calculate_metrics()`: Computes various performance indicators.
    -   `_check_termination()`: Determines if the simulation should end (e.g., time limit, all drones inactive).
    -   `render()`: Draws the current state of the simulation.
    -   `close_visualization()`: Handles the closing of the plot window.

### Simulation Scripts (`run_simulation.py` and `src/main.py`)

Both scripts provide a way to run the simulation. They define simulation parameters, initialize the `Environment`, run the main simulation loop, and handle the display of results. `src/main.py` additionally includes more detailed post-simulation plotting of metrics over time using `pandas`.

## Potential Areas for Future Development

-   **3D Environment**: Extend the simulation to operate in three dimensions.
-   **Obstacle Avoidance**: Implement algorithms for drones to detect and avoid obstacles in the environment.
-   **More Sophisticated Energy Models**: Include energy costs for communication or specific tasks.
-   **Task Allocation**: Allow drones to perform tasks beyond corridor formation.
-   **Decentralized Control**: Explore more decentralized decision-making algorithms for the drones.
-   **GUI for Parameter Tuning**: Develop a graphical user interface to easily adjust simulation parameters and observe their effects.
-   **Advanced Path Planning**: Implement more advanced pathfinding algorithms for the swarm or individual drones.
-   **Fault Tolerance**: Simulate drone failures and how the swarm adapts.

This README provides a basic overview. You can explore the code for more detailed understanding of the implementation. 
